import firebase_admin
from firebase_admin import credentials, db
import tkinter as tk
from tkinter import messagebox
from PIL import Image, ImageTk
import pygame

# Inicializar Firebase
cred = credentials.Certificate("credencial.json")
firebase_admin.initialize_app(cred, {
    'databaseURL': 'https://pong-3e97f-default-rtdb.firebaseio.com/'
})

# Configuración del juego
WIDTH, HEIGHT = 800, 600
PAD_WIDTH, PAD_HEIGHT = 20, 100
BALL_SIZE = 20
BALL_SPEED = 5
MAX_BALL_SPEED = 15
PADDLE_SPEED = 6

# Variables globales para el estado del juego
left_pad_pos = HEIGHT // 2 - PAD_HEIGHT // 2
right_pad_pos = HEIGHT // 2 - PAD_HEIGHT // 2
ball_pos = [WIDTH // 2, HEIGHT // 2]
ball_vel = [BALL_SPEED, BALL_SPEED]

def start_game():
    # Ocultar el menú principal
    title_label.pack_forget()
    button_frame.pack_forget()
    background_label.pack_forget()

    # Mostrar el lienzo del juego
    game_frame.pack()

    # Iniciar el juego de Pong
    run_pong()

def show_options():
    options_frame.pack(pady=20)

def exit_game():
    window.quit()

def run_pong():
    def game_loop():
        # Inicialización de Pygame
        pygame.init()
        screen = pygame.display.set_mode((WIDTH, HEIGHT))
        pygame.display.set_caption("Pong en Python")

        # Variables del juego
        paleta_izquierda = HEIGHT // 2 - PAD_HEIGHT // 2
        paleta_derecha = HEIGHT // 2 - PAD_HEIGHT // 2
        pelota_1 = [WIDTH // 2, HEIGHT // 2]
        pelota_vel = [BALL_SPEED, BALL_SPEED]
        paddle_speed = PADDLE_SPEED
        score_left = 0
        score_right = 0
        high_time = 0

        # Colores
        WHITE = (255, 255, 255)
        BLACK = (0, 0, 0)

        # Fuente para el marcador y tiempo
        font = pygame.font.Font(None, 36)

        # Bucle principal
        running = True
        clock = pygame.time.Clock()
        start_ticks = pygame.time.get_ticks()

        while running:
            screen.fill(BLACK)

            # Tiempo transcurrido
            seconds = (pygame.time.get_ticks() - start_ticks) // 1000

            # Manejo de eventos
            keys = pygame.key.get_pressed()
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False

            # Movimiento de las paletas
            if keys[pygame.K_w] and paleta_izquierda > 0:
                paleta_izquierda -= paddle_speed
            if keys[pygame.K_s] and paleta_izquierda < HEIGHT - PAD_HEIGHT:
                paleta_izquierda += paddle_speed
            if keys[pygame.K_UP] and paleta_derecha > 0:
                paleta_derecha -= paddle_speed
            if keys[pygame.K_DOWN] and paleta_derecha < HEIGHT - PAD_HEIGHT:
                paleta_derecha += paddle_speed

            # Movimiento de la pelota
            pelota_1[0] += pelota_vel[0]
            pelota_1[1] += pelota_vel[1]

            # Rebote en las paredes superior e inferior
            if pelota_1[1] <= 0 or pelota_1[1] >= HEIGHT - BALL_SIZE:
                pelota_vel[1] = -pelota_vel[1]

            # Detección de colisión con las paletas
            if (pelota_1[0] <= PAD_WIDTH and paleta_izquierda < pelota_1[1] < paleta_izquierda + PAD_HEIGHT) or \
               (pelota_1[0] >= WIDTH - PAD_WIDTH - BALL_SIZE and paleta_derecha < pelota_1[1] < paleta_derecha + PAD_HEIGHT):
                pelota_vel[0] = -pelota_vel[0]

            # Si la pelota sale por la izquierda o derecha
            if pelota_1[0] < 0 or pelota_1[0] > WIDTH:
                end_ticks = pygame.time.get_ticks()
                play_time = (end_ticks - start_ticks) // 1000
                if play_time > high_time:
                    high_time = play_time
                    update_high_score(high_time)
                start_ticks = pygame.time.get_ticks()  # Reiniciar el contador de tiempo
                pelota_1 = [WIDTH // 2, HEIGHT // 2]
                pelota_vel = [BALL_SPEED, BALL_SPEED] if pelota_1[0] < 0 else [-BALL_SPEED, -BALL_SPEED]
                if ball_pos[0] < 0:
                    score_right += 1
                else:
                    score_left += 1

            # Aumentar la velocidad de la pelota mientras más dure en juego
            if pelota_vel[0] < MAX_BALL_SPEED and pelota_vel[0] > -MAX_BALL_SPEED:
                pelota_vel[0] += 0.01 if pelota_vel[0] > 0 else -0.01
            if pelota_vel[1] < MAX_BALL_SPEED and pelota_vel[1] > -MAX_BALL_SPEED:
                pelota_vel[1] += 0.01 if pelota_vel[1] > 0 else -0.01

            # Ajustar la velocidad de las paletas en función de la velocidad de la pelota
            paddle_speed = max(PADDLE_SPEED, abs(pelota_vel[0] / 2))

            # Dibujar elementos
            pygame.draw.rect(screen, WHITE, (0, paleta_izquierda, PAD_WIDTH, PAD_HEIGHT))
            pygame.draw.rect(screen, WHITE, (WIDTH - PAD_WIDTH, paleta_derecha, PAD_WIDTH, PAD_HEIGHT))
            pygame.draw.ellipse(screen, WHITE, (pelota_1[0], pelota_1[1], BALL_SIZE, BALL_SIZE))
            pygame.draw.aaline(screen, WHITE, (WIDTH // 2, 0), (WIDTH // 2, HEIGHT))

            # Mostrar marcador y tiempo
            score_text = font.render(f"{score_left}  -  {score_right}", True, WHITE)
            screen.blit(score_text, (WIDTH // 2 - 30, 20))
            time_text = font.render(f"Tiempo: {seconds}s", True, WHITE)
            screen.blit(time_text, (10, 10))

            # Actualizar pantalla
            pygame.display.flip()
            clock.tick(60)

        pygame.quit()
        # Restaurar la interfaz de Tkinter después de cerrar Pygame
        game_frame.pack_forget()
        background_label.place(relwidth=1, relheight=1)
        title_label.pack(pady=40)
        button_frame.pack(pady=20)

    # Ejecutar el bucle del juego de Pygame en un hilo separado
    window.after(100, game_loop)

def update_high_score(new_high_score):
    ref = db.reference('high_score')
    current_high_score = ref.get()
    if new_high_score > current_high_score:
        ref.set(new_high_score)

def view_high_score():
    ref = db.reference('high_score')
    high_score = ref.get()
    messagebox.showinfo("Mayor Récord", f"El mayor récord es: {high_score}")

def delete_high_score():
    ref = db.reference('high_score')
    ref.set(0)
    messagebox.showinfo("Mayor Récord", "El récord ha sido eliminado.")

# Crear la ventana principal
window = tk.Tk()
window.title("Pong")
window.geometry("800x600")

# Cargar la imagen de fondo
background_image = Image.open("background.JPEG")
background_photo = ImageTk.PhotoImage(background_image)

# Crear un widget de etiqueta para la imagen de fondo
background_label = tk.Label(window, image=background_photo)
background_label.place(relwidth=1, relheight=1)

# Crear el título del juego
title_label = tk.Label(window, text="Pong", font=("Arial", 44), fg="white", bg="black")
title_label.pack(pady=40)

# Crear los botones del menú
button_frame = tk.Frame(window, bg="black")
button_frame.pack(pady=20)

new_game_button = tk.Button(button_frame, text="Nuevo Juego", font=("Arial", 20), width=12, height=2, command=start_game)
new_game_button.pack(pady=5)

options_button = tk.Button(button_frame, text="Opciones", font=("Arial", 20), width=12, height=2, command=show_options)
options_button.pack(pady=5)

exit_button = tk.Button(button_frame, text="Salir", font=("Arial", 20), width=12, height=2, command=exit_game)
exit_button.pack(pady=5)

# Crear el marco del juego y el lienzo
game_frame = tk.Frame(window, bg="black")
canvas = tk.Canvas(game_frame, bg="black", width=WIDTH, height=HEIGHT)
canvas.pack()

# Crear el marco de opciones
options_frame = tk.Frame(window, bg="black")
view_score_button = tk.Button(options_frame, text="Ver Mayor Récord", font=("Arial", 20), width=18, height=2, command=view_high_score)
view_score_button.pack(pady=5)

delete_score_button = tk.Button(options_frame, text="Eliminar Mayor Récord", font=("Arial", 20), width=18, height=2, command=delete_high_score)
delete_score_button.pack(pady=5)

# Ejecutar la ventana principal
window.mainloop()
